import numpy as np 
import matplotlib.pyplot as plt 
from math import *
import time 
from copy import deepcopy

start = time.time()

BOX_SIZE = 0.01
MIN_X = MIN_Y = -1.4
MAX_X = MAX_Y = 1.4
MAX_ITERATIONS = 1000


class Box:
	def __init__(self, minXY, size): #minXY is an array with 2 elements: the minimum X followed by the maximum
		self.minXY = minXY
		self.size = size
		self.hasPoint = False

	def contains(self, point: list):
		if (point[0] > self.minXY[0]) and (point[0] < self.minXY[0] + self.size) and (point[1] > self.minXY[1]) and (point[1] < self.minXY[1] + self.size):
			self.hasPoint = True

	def equals(self, otherBox):
		if (self.minXY == otherBox.minXY) and (self.size == otherBox.size):
			return True
		return False

#Determining if a given complex number z converges after a given number of iterations with a given constant C, where the z_n is defined by the recursive formula z_n = (z_(n-1))^2 + C 
def converges(z, C):
	current = z
	for i in range(MAX_ITERATIONS): # change back to MAX_ITERATIONS
		current = current**2 + C
		if (abs(current) > 2):
			return False
	return True

#Rounding a complex number c to some n decimal places
def cround(z: complex, n):
	a = z.real
	b = z.imag
	res = round(a, n) + round(b, n)*1j
	return res

def intersection(lst1, lst2):
    lst3 = [value for value in lst1 if value in lst2]
    return len(lst3)

def julia_set(x_min, x_max, y_min, y_max, C, toSave):
	''' A function to determine the values of the Julia set. Takes
	a minimum and maximum x/y values, along with the C that defines the Julia set (in the eq'n z_n = (z_(n-1))^2 + C).  
	Returns an array with the set of complex numbers which belong to the Julia set for the given C.
	'''
	# # top left to bottom right
	# y, x = np.ogrid[1.4: -1.4: h_range*1j, -1.4: 1.4: w_range*1j]
	# z_array = x + y*1j
	# # print(z_array)
	# print(z_array.shape)
	# a = -0.744 + 0.148j
	# iterations_until_divergence = max_iterations + np.zeros(z_array.shape)
	x_vals = np.linspace(x_min, x_max, num=int((x_max - x_min) / BOX_SIZE + 2))
	y_vals = np.linspace(y_min, y_max, num=int((y_max - y_min) / BOX_SIZE + 2))
	z_arr = []
	satisfied = []
	unsatisfied = []
	for x in range(len(x_vals)):
		for y in range(len(y_vals)):
			z_arr.append(cround(x_vals[x] + y_vals[y]*1j, 2))
			if (converges(z_arr[-1], C)):
				satisfied.append(z_arr[-1])
			else:
				unsatisfied.append(z_arr[-1])
	
	if toSave:
		print("bor")
		with open("fractalList.txt", "a") as f:
			f.write(f"C = {C}:\n")
			for i in satisfied:
				f.write(f"{i.real}, {i.imag}\n")
			f.close() 

	return satisfied

def comparative_sensitivity(J_a, J_b):
	return (len(J_a) + len(J_b) - 2*intersection(J_a, J_b)) / (len(J_a))

# j1s = [0.2, 0.15, 0.1, 0.09, 0.08, 0.07, 0.06, 0.05, 0.04, 0.03, 0.02, 0.01]

orig = 0.04
j1s = [orig]
for i in range(30):
	orig -= 0.001
	j1s.append(round(orig, 3))

for j in j1s:
	j1 = julia_set(MIN_X, MAX_X, MIN_Y, MAX_Y, j, False)
	j2 = julia_set(MIN_X, MAX_X, MIN_Y, MAX_Y, 0, False)
	sensitivity = comparative_sensitivity(j1, j2)
	print(f"The ratio of the sensitivity of J_(C + h*u) on J_C when C = 0, h = {j}, u = <1, 0> is {sensitivity/j}.")



def comparative_box_sensitivity(J_a: list[Box], J_b: list[Box]):
	return (len(J_a) + len(J_b) - 2*boxIntersection(J_a, J_b)) / (len(J_a))

def comparative_resistivity(J_a, J_b):
	return 1 - comparative_sensitivity(J_a, J_b)

def roots_of_unity(r, n):
	print(0)
	res = []
	for k in range(n):
		res.append(r * (cis(2*pi*k/n)))
	return res

def cis(theta):
	return cos(theta) + sin(theta)*1j

#print(cround(2 + 1.05347829j, 4)); print("\n")

arr_1 = [1,2,3,4,5]
arr_2 = [6,7,8,9,10]

#print(f"The sensitivity of the Julia set generated by C = 0.0001 on that of C = 0 is {comparative_sensitivity(julia_set(MIN_X, MAX_X, MIN_Y, MAX_Y, 0), julia_set(MIN_X, MAX_X, MIN_Y, MAX_Y, 0.0001))}")

#print(f"The sensitivity of the Julia set generated by C = 0.01 on that of C = 0 is {comparative_sensitivity(julia_set(MIN_X, MAX_X, MIN_Y, MAX_Y, 0), julia_set(MIN_X, MAX_X, MIN_Y, MAX_Y, 0.01))}")

def spaceIt():
	gh = np.linspace(0.01, 1, 100)
	print(gh)

	full_picture = []
	for r in gh:
		temp = []
		points = roots_of_unity(r, 6)
		for p in points:
			temp.append(comparative_sensitivity(julia_set(MIN_X, MAX_X, MIN_Y, MAX_Y, 0, False), julia_set(MIN_X, MAX_X, MIN_Y, MAX_Y, p, False)))
		full_picture.append(temp)
	print(full_picture)

#spaceIt()

# julia_set(MIN_X, MAX_X, MIN_Y, MAX_Y, 0, True)
# julia_set(MIN_X, MAX_X, MIN_Y, MAX_Y, 0.0001, True)


pointszero = []
pointsclose = []
with open("fractalList.txt", "r") as f:
	markers = []
	lines = f.readlines()
	
	# for line in lines:
	# 	bash = line.split(": ")

# print(markers)

# converges(-0.02 + 0.03*1j, 0.6+0.8*1j)


def boxIntersection(boxes1: list[Box], boxes2: list[Box]):
    # lst3 = [value for value in lst1 if value.]
    # return len(lst3)
	common = []
	for b1 in boxes1:
		for b2 in boxes2:
			if b1.equals(b2):
				common.append(b1)
	return len(common)

#parameters: C1, C2, BOX_SIZE

BOX_SIZE = 0.2


Xset = np.linspace(MIN_X, MAX_X, num=int((MAX_X - MIN_X) / BOX_SIZE + 2))
Yset = np.linspace(MIN_Y, MAX_Y, num=int((MAX_X - MIN_X) / BOX_SIZE + 2))

Xset = Xset[:-1]
Yset = Yset[:-1]

boxes1 = []
for minx in Xset:
	for miny in Yset:
		boxes1.append(Box([minx, miny], BOX_SIZE))

boxes2 = deepcopy(boxes1)

first_c_val = 0
first_c_boxes = []
numberList1 = julia_set(MIN_X, MAX_X, MIN_Y, MAX_Y, first_c_val, False)
for b in boxes1:
	for n in numberList1:
		b.contains([n.real, n.imag])

for b in boxes1:
	if (b.hasPoint):
		first_c_boxes.append(b)

second_c_val = 0.2
second_c_boxes = []
numberList2 = julia_set(MIN_X, MAX_X, MIN_Y, MAX_Y, second_c_val, False)
for b in boxes2:
	for n in numberList2:
		b.contains([n.real, n.imag])

for b in boxes2:
	if (b.hasPoint):
		second_c_boxes.append(b)

intersect = boxIntersection(first_c_boxes, second_c_boxes)
# print(f"The sensitivity of C = 0.1 on C = 0 with grid size 0.05 is {1 - intersect/len(first_c_boxes)}")
# print(f"The sensitivity of C = 0.2 on C = 0 with grid size 0.05 is {comparative_box_sensitivity(first_c_boxes, second_c_boxes)}")
# print(f"The number of boxes covered in a grid with width 0.2 by J_C where C = 0.2, is {len(second_c_boxes)} squares.")


end = time.time()	
print(f"Runtime: {end-start}s")